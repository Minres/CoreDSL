/*
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.tests

import com.google.inject.Inject
import com.minres.coredsl.coreDsl.AssignmentExpression
import com.minres.coredsl.coreDsl.CompoundStatement
import com.minres.coredsl.coreDsl.DescriptionContent
import com.minres.coredsl.coreDsl.Declarator
import com.minres.coredsl.coreDsl.ExpressionStatement
import com.minres.coredsl.coreDsl.InstructionSet
import com.minres.coredsl.coreDsl.IntegerConstant
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith

import static org.junit.jupiter.api.Assertions.assertEquals
import static org.junit.jupiter.api.Assertions.assertFalse
import static org.junit.jupiter.api.Assertions.assertTrue
import com.minres.coredsl.coreDsl.EntityReference

@ExtendWith(InjectionExtension)
@InjectWith(CoreDslInjectorProvider)
class CoreDslTerminalsTest {

    @Inject extension ParseHelper<DescriptionContent> parseHelper

    @Inject ValidationTestHelper validator

    def CharSequence addBehaviorContext(CharSequence str) '''
        InstructionSet TestISA {
            instructions {
            	FOO {
            		encoding: 0b0000000 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1111011;  
            		assembly: "{name(rd)}, {name(rs1)}, {name(rs2)}";
            		behavior: {
            			«str»
            		}
            	}
            }
        }
    '''

    def assertIssues(CharSequence str) {
        val content = addBehaviorContext(str).parse
        val issues = validator.validate(content)
        assertFalse(issues.isEmpty())
    }

    @Test
    def void parseIntLiterals() {
        val content = addBehaviorContext('''
            unsigned int c;
            unsigned<6> v;
            // C syntax
            c = 42;
            c = 0x2A;
            c = 052;
            c = 0b101010;
            
            // Verilog syntax
            v = 6'd42;
            v = 6'h2a;
            v = 6'o52;
            v = 6'b101010;
         	''').parse
        validator.assertNoErrors(content)

        val compound = ((content.definitions.get(0) as InstructionSet).instructions.get(0).behavior as CompoundStatement)
        for (el : compound.statements) {
            if (el instanceof ExpressionStatement) {
                val expr = el.expression as AssignmentExpression
                val rhs = expr.value as IntegerConstant
                assertEquals(rhs.value.intValue, 42)
            }
        }
    }

    @Test
    def void parseBoolLiterals() {
        val content = addBehaviorContext('''
            bool b;
            b = true;
            b = false;
        ''').parse
        validator.assertNoErrors(content)
    }

    @Test
    def void parseSingleCharIdentifiers() {
        // this test is here because the encoding prefixes for char- and string literals may clobber normal identifiers
        var alphabet = "abcdefghijklmnopqrstuvwxyz"
        alphabet += alphabet.toUpperCase
        for (var i = 0; i < alphabet.length; i++) {
            val c = alphabet.charAt(i);
            val content = addBehaviorContext('''int «c»;''').parse
            val issues = validator.validate(content)
            if (! issues.isEmpty) {
                println("Problematic identifier: " + c)
                for (issue : issues)
                    println(issue)
            }
            validator.assertNoErrors(content)
        }
    }
}
