/*
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.tests.syntax

import com.google.inject.Inject
import com.minres.coredsl.coreDsl.DescriptionContent
import com.minres.coredsl.tests.CoreDslInjectorProvider
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import com.minres.coredsl.coreDsl.Instruction
import com.minres.coredsl.coreDsl.FunctionDefinition
import org.eclipse.emf.common.util.EList
import com.minres.coredsl.validation.IssueCodes
import com.minres.coredsl.coreDsl.CoreDslPackage
import static org.junit.jupiter.api.Assertions.*
import com.minres.coredsl.coreDsl.IfStatement
import com.minres.coredsl.coreDsl.Statement

@ExtendWith(InjectionExtension)
@InjectWith(CoreDslInjectorProvider)
class CoreDslSyntaxTest {

	@Inject extension ParseHelper<DescriptionContent> parseHelper

	@Inject ValidationTestHelper validator

	def Instruction parseAsInstruction(CharSequence str) {
		return '''
			InstructionSet TestISA {
			    instructions {
			        «str»
			    }
			}
		'''.parse().definitions.get(0).instructions.get(0);
	}

	def FunctionDefinition parseAsFunction(CharSequence str) {
		return '''
			InstructionSet TestISA {
			    functions {
			    	«str»
			    }
			}
		'''.parse().definitions.get(0).functions.get(0);
	}

	def EList<Statement> parseAsStatements(CharSequence str) {
		return '''
			InstructionSet TestISA {
			    functions {
			    	void testFunc() {
			    		«str»
			    	}
			    }
			}
		'''.parse().definitions.get(0).functions.get(0).body.statements;
	}

	def Statement parseAsStatement(CharSequence str) {
		return str.parseAsStatements().get(0);
	}

	@Test
	def void parseDescriptionContentValid() {

		// one core definition, no imports
		validator.assertNoErrors('''Core A {}'''.parse(), IssueCodes.SyntaxError)

		// one instruction set, no imports
		validator.assertNoErrors('''InstructionSet A {}'''.parse(), IssueCodes.SyntaxError)

		// multiple definitions, no imports
		validator.assertNoErrors('''
			InstructionSet A {}
			Core B {}
			InstructionSet C {}
			Core D {}
		'''.parse(), IssueCodes.SyntaxError)

		// one core definition, imports
		validator.assertNoErrors('''
			import "a.core_desc"
			import "b.core_desc"
			Core A {}
		'''.parse(), IssueCodes.SyntaxError)

		// one instruction set, imports
		validator.assertNoErrors('''
			import "a.core_desc"
			import "b.core_desc"
			InstructionSet A {}
		'''.parse(), IssueCodes.SyntaxError)

		// multiple definitions, imports
		validator.assertNoErrors('''
			import "a.core_desc"
			import "b.core_desc"
			InstructionSet A {}
			Core B {}
			InstructionSet C {}
			Core D {}
		'''.parse(), IssueCodes.SyntaxError)

		// all on the same line
		validator.assertNoErrors('''import "a.core_desc" import "b.core_desc" Core A {}'''.parse(),
			IssueCodes.SyntaxError)
	}

	@Test
	def void parseDescriptionContentInvalid() {

		// empty description (for some reason this doesn't even bother creating an instance, but just returns null)
		assertNull("".parse())

		// import after definition
		validator.assertError('''
			Core A {}
			import "a.core_desc"
		'''.parse(), CoreDslPackage.Literals.DESCRIPTION_CONTENT, IssueCodes.SyntaxError);
	}

	@Test
	def void parseInstructionSetValid() {

		// empty instruction set
		validator.assertNoErrors('''
			InstructionSet A {}
		'''.parse(), IssueCodes.SyntaxError);

		// inheritance
		validator.assertNoErrors('''
			InstructionSet B extends A {}
		'''.parse(), IssueCodes.SyntaxError);

		// single section
		validator.assertNoErrors('''
			InstructionSet A { architectural_state { int x; } }
			InstructionSet B { functions { void x() {} } }
			InstructionSet C { instructions { x { encoding: 0; behavior: {} } } }
		'''.parse(), IssueCodes.SyntaxError);

		// section permutations
		validator.assertNoErrors('''
			InstructionSet AFI {
				architectural_state { int x; }
				functions { void x() {} }
				instructions { x { encoding: 0; behavior: {} } }
			}
			InstructionSet AIF {
				architectural_state { int x; }
				instructions { x { encoding: 0; behavior: {} } }
				functions { void x() {} }	
			}
			InstructionSet FAI {
				functions { void x() {} }
				architectural_state { int x; }
				instructions { x { encoding: 0; behavior: {} } }
			}
			InstructionSet FIA {
				functions { void x() {} }
				instructions { x { encoding: 0; behavior: {} } }
				architectural_state { int x; }
			}
			InstructionSet IAF {
				instructions { x { encoding: 0; behavior: {} } }
				architectural_state { int x; }
				functions { void x() {} }
			}
			InstructionSet IFA {
				instructions { x { encoding: 0; behavior: {} } }
				functions { void x() {} }
				architectural_state { int x; }
			}
		'''.parse(), IssueCodes.SyntaxError);
	}

	@Test
	def void parseInstructionSetInvalid() {

		// empty sections
		val content = '''
			InstructionSet A { architectural_state {} }
			InstructionSet B { functions {} }
			InstructionSet C { instructions {} }
		'''.parse();
		for (set : content.definitions) {
			validator.assertError(set, CoreDslPackage.Literals.ISA, IssueCodes.SyntaxError);
		}

		// multiple inheritance
		validator.assertError('''
			InstructionSet A extends B, C {}
		'''.parse(), CoreDslPackage.Literals.INSTRUCTION_SET, IssueCodes.SyntaxError);

		// provides keyword
		validator.assertError('''
			InstructionSet A provides B {}
		'''.parse(), CoreDslPackage.Literals.INSTRUCTION_SET, IssueCodes.SyntaxError);
	}

	@Test
	def void parseCoreDefValid() {

		// empty core
		validator.assertNoErrors('''
			Core A {}
		'''.parse(), IssueCodes.SyntaxError);

		// provides one
		validator.assertNoErrors('''
			Core A provides B {}
		'''.parse(), IssueCodes.SyntaxError);

		// provides multiple
		validator.assertNoErrors('''
			Core A provides B, C, D {}
		'''.parse(), IssueCodes.SyntaxError);

		// single section
		validator.assertNoErrors('''
			Core A { architectural_state { int x; } }
			Core B { functions { void x() {} } }
			Core C { instructions { x { encoding: 0; behavior: {} } } }
		'''.parse(), IssueCodes.SyntaxError);

		// section permutations
		validator.assertNoErrors('''
			Core AFI {
				architectural_state { int x; }
				functions { void x() {} }
				instructions { x { encoding: 0; behavior: {} } }
			}
			Core AIF {
				architectural_state { int x; }
				instructions { x { encoding: 0; behavior: {} } }
				functions { void x() {} }
			}
			Core FAI {
				functions { void x() {} }
				architectural_state { int x; }
				instructions { x { encoding: 0; behavior: {} } }
			}
			Core FIA {
				functions { void x() {} }
				instructions { x { encoding: 0; behavior: {} } }
				architectural_state { int x; }
			}
			Core IAF {
				instructions { x { encoding: 0; behavior: {} } }
				architectural_state { int x; }
				functions { void x() {} }
			}
			Core IFA {
				instructions { x { encoding: 0; behavior: {} } }
				functions { void x() {} }
				architectural_state { int x; }
			}
		'''.parse(), IssueCodes.SyntaxError);
	}

	@Test
	def void parseCoreDefInvalid() {

		// empty sections
		val content = '''
			Core A { architectural_state {} }
			Core B { functions {} }
			Core C { instructions {} }
		'''.parse();
		for (set : content.definitions) {
			validator.assertError(set, CoreDslPackage.Literals.ISA, IssueCodes.SyntaxError);
		}

		// extends keyword
		validator.assertError('''
			Core A extends B {}
		'''.parse(), CoreDslPackage.Literals.CORE_DEF, IssueCodes.SyntaxError);
	}

	@Test
	def void parseInstructionValid() {

		// without assembly
		validator.assertNoErrors('''
			Core A { instructions { x {
				encoding: 0;
				behavior: {}
			} } }
		'''.parse(), IssueCodes.SyntaxError);

		// with assembly
		validator.assertNoErrors('''
			Core A { instructions { x {
				encoding: 0;
				assembly: "";
				behavior: {}
			} } }
		'''.parse(), IssueCodes.SyntaxError);

		// complex encoding
		validator.assertNoErrors('''
			Core A { instructions { x {
				encoding: 1 :: 4'hf :: 0x2 :: 0b101010 :: 0777 :: fld[0:3];
				behavior: {}
			} } }
		'''.parse(), IssueCodes.SyntaxError);

		// non-compound statement behavior
		validator.assertNoErrors('''
			Core A { instructions { x {
				encoding: 0;
				behavior: x = 5;
			} } }
		'''.parse(), IssueCodes.SyntaxError);
	}

	@Test
	def void parseInstructionInvalid() {

		// invalid permutations
		val instructions = #[
			'_ { }',
			'e { encoding: 11; }',
			'a { assembly: ""; }',
			'b { behavior: {} }',
			'be { behavior: {} encoding: 11; }',
			'eba { encoding: 11; behavior: {} assembly: ""; }',
			'aeb { assembly: ""; encoding: 11; behavior: {} }',
			'abe { assembly: ""; behavior: {} encoding: 11; }',
			'bea { behavior: {} encoding: 11; assembly: ""; }',
			'bae { behavior: {} assembly: ""; encoding: 11; }'
		];
		for (inst : instructions) {
			val content = '''Core A { instructions { «inst» } }'''.parse();
			var issues = validator.validate(content);
			assertTrue(issues.filter[it.code == IssueCodes.SyntaxError].length > 0);
		}
	}

	@Test
	def void parseDeclarationsValid() {
		val statements = '''
			
			// single declarator
			int i;
			
			// multiple declarators
			int i, j, k;
			
			// single init declarator
			int i = 10;
			
			// multiple init declarators
			int i = 10, j = 20, k = 30;
			
			// mixed regular and init declarators
			int i, j = 20, k;
			
		'''.parseAsStatements();

		for (statement : statements) {
			validator.assertNoErrors(statement, IssueCodes.SyntaxError);
		}
	}

	@Test
	def void parseTypeSpecifiersValid() {
		val statements = '''
			
			signed<32> i;
			unsigned<XLEN> i;
			
			char i;
			signed char i;
			unsigned char i;
			
			short i;
			signed short i;
			unsigned short i;
			
			int i;
			signed int i;
			unsigned int i;
			
			long i;
			signed long i;
			unsigned long i;
			
			bool i;
			float i;
			double i;
			
		'''.parseAsStatements();

		for (statement : statements) {
			validator.assertNoErrors(statement, IssueCodes.SyntaxError);
		}
	}

	@Test
	def void parseTypeSpecifiersInvalid() {
		val statements = '''
			
			signed i;
			unsigned i;
			
		'''.parseAsStatements();

		for (statement : statements) {
			validator.assertError(statement, CoreDslPackage.Literals.DECLARATOR, IssueCodes.SyntaxError);
		}
	}

	@Test
	def void parseIfStatementValid() {
		val statements = '''
			
			if(false);
			
			if(false) {}
			
			if(false) if(true);
			
			if(false);
			else;
			
			if(false) {}
			else {}
			
			if(false);
			else if(true);
			else;
			
			if(false) {}
			else if(true) {}
			else {}
			
			if((((false))));
			
		'''.parseAsStatements();

		for (statement : statements) {
			validator.assertNoErrors(statement, IssueCodes.SyntaxError);
		}

		// check that the else is properly associated with the inner if
		val ifstmt = '''
			
			if(false)
			if(true);
			else;
			
		'''.parseAsStatements().get(0) as IfStatement;

		assertNull(ifstmt.elseBody);
		assertNotNull((ifstmt.thenBody as IfStatement).elseBody);
	}

	@Test
	def void parseIfStatementInvalid() {
		// else must follow an if statement
		validator.assertError('''
			
			{
				else;
			}
			
		'''.parseAsStatement(), CoreDslPackage.Literals.COMPOUND_STATEMENT, IssueCodes.SyntaxError);

		// at most one else per if statement
		validator.assertError('''
			
			{
				if(false);
				else;
				else;
			}
			
		'''.parseAsStatement(), CoreDslPackage.Literals.COMPOUND_STATEMENT, IssueCodes.SyntaxError);

		// parentheses are required
		// NOTE: it makes no sense, but this error is reported on the false and {} nodes, instead of the if statement
		validator.assertError('''
			
			if false {}
			
		'''.parseAsStatement(), CoreDslPackage.Literals.BOOL_CONSTANT, IssueCodes.SyntaxError);

		// then statement is required
		validator.assertError('''
			
			if(false)
			
		'''.parseAsStatement(), CoreDslPackage.Literals.COMPOUND_STATEMENT, IssueCodes.SyntaxError);

		// else statement is required if else keyword is present
		validator.assertError('''
			
			if(false);
			else
			
		'''.parseAsStatement(), CoreDslPackage.Literals.COMPOUND_STATEMENT, IssueCodes.SyntaxError);
	}

	@Test
	def void parseSwitchStatementValid() {
		val statements = '''
			
			// no sections
			switch(1) { }
			
			// simple default
			switch(1) { default: }
			
			// complex switch expression
			switch((((1)))) { default: }
			
			// multiple defaults
			switch(1) { default: default: default: }
			
			// simple case
			switch(1) { case 0: }
			
			// complex case expression
			switch(1) { case (((0))): }
			
			// default last
			switch(1) { case 0: case 1: default: }
			
			// default in between
			switch(1) { case 0: default: case 1: }
			
			// default first
			switch(1) { default: case 0: case 1: }
			
			// mixed sections, multiple defaults
			switch(1) { default: case 0: default: case 1: default: }
			
			// one section, one statement
			switch(1) { case 0: {} }
			
			// one section, multiple statements
			switch(1) { case 0: {};; }
			
			// multiple sections, at most one statement each
			switch(1) { case 0: case 1: ; default: {} }
			
			// multiple sections, multiple statements
			switch(1) { case 0: case 1: ;;; default: {};; }
			
		'''.parseAsStatements();

		for (statement : statements) {
			validator.assertNoErrors(statement, IssueCodes.SyntaxError);
		}
	}

	@Test
	def void parseSwitchStatementInvalid() {
		// parentheses are required
		validator.assertError('''
			
			switch 5 { default: }
			
		'''.parseAsStatement(), CoreDslPackage.Literals.INTEGER_CONSTANT, IssueCodes.SyntaxError);

		// switch body is required
		validator.assertError('''
			
			switch(5);
			
		'''.parseAsStatement(), CoreDslPackage.Literals.EMPTY_STATEMENT, IssueCodes.SyntaxError);

		// case needs a condition
		validator.assertError('''
			
			switch(5) { case: }
			
		'''.parseAsStatement(), CoreDslPackage.Literals.SWITCH_SECTION, IssueCodes.SyntaxError);

		// default must not have a condition
		validator.assertError('''
			
			switch(5) { default 0: }
			
		'''.parseAsStatement(), CoreDslPackage.Literals.SWITCH_SECTION, IssueCodes.SyntaxError);
	}

	@Test
	def void parseLoopValid() {
		val statements = '''
			
			// simple while
			while(true) {}
			
			// while without compound
			while(true);
			
			// while with complex condition
			while((((true)))) {}
			
			// simple do
			do {} while(true);
			
			// do without compound
			do ; while(true);
			
			// do with complex condition
			do {} while((((true))));
			
			// simple for
			for(;;) {}
			
			// for without compound
			for(;;);
			
			// for with complex condition
			for(;(((true)));) {}
			
			// for with single init declaration
			for(int i = 0;;) {}
			
			// for with multiple init declarations
			for(int i, j = 0, k;;) {}
			
			// for with single init assignment
			for(i = 0;;) {}
			
			// for with single init assignment (increment)
			for(i++;;) {}
			
			// for with single increment assignment
			for(;;i = 7) {}
			
			// for with multiple increment assignments
			for(;;i = 7, j++, --k) {}
			
		'''.parseAsStatements();

		for (statement : statements) {
			validator.assertNoErrors(statement, IssueCodes.SyntaxError);
		}
	}

	@Test
	def void parseLoopInvalid() {
		// while parentheses are required
		validator.assertError('''
			
			while true {}
			
		'''.parseAsStatement(), CoreDslPackage.Literals.BOOL_CONSTANT, IssueCodes.SyntaxError);

		// do parentheses are required
		validator.assertError('''
			
			do {} while true;
			
		'''.parseAsStatement(), CoreDslPackage.Literals.BOOL_CONSTANT, IssueCodes.SyntaxError);

		// do while is required
		validator.assertError('''
			
			do {}
			
		'''.parseAsStatement(), CoreDslPackage.Literals.COMPOUND_STATEMENT, IssueCodes.SyntaxError);
	}
}
