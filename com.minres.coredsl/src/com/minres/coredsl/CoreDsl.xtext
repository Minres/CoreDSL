grammar com.minres.coredsl.CoreDsl with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate coreDsl "http://www.minres.com/coredsl/CoreDsl/2.0"

DescriptionContent: (imports+=Import)* definitions+=(InstructionSet | CoreDef)+;

Import: 'import' importURI=STRING;

InstructionSet : 'InstructionSet' name=ID ( 'extends' superType=[InstructionSet] )? '{' ISA '}';

CoreDef: 'Core' name=ID ( 'provides' contributingType+=[InstructionSet] (',' contributingType+=[InstructionSet])*)? '{' ISA '}';

fragment ISA:
	('architectural_state' '{' (declarations+=Declaration | assignments+=ExpressionStatement)+ '}')? &
	('functions' '{' functions+=FunctionDefinition+ '}')? &
	('instructions' commonInstructionAttributes+=Attribute* '{' instructions+=Instruction+ '}')?;

Instruction:
	name=ID attributes+=Attribute* '{' 
		('encoding' ':' encoding=Encoding ';')
		('assembly' ':' assembly=STRING ';')?
		('behavior' ':' behavior=Statement)
	'}'
;

Encoding
	:	fields+=Field ('::' fields+=Field)*
	;

Field
	: 	BitValue
	|	BitField
	;

BitValue
	: 	value=INTEGER
	;

BitField
	:	name=ID LEFT_BR left=IntegerConstant ':' right=IntegerConstant RIGHT_BR 
	;

FunctionDefinition
	:   extern?='extern' type=TypeSpecifier name=ID '(' (parameters+=ParameterDeclaration (',' parameters+=ParameterDeclaration)*)? ')' ';'
	|   type=TypeSpecifier name=ID '(' (parameters+=ParameterDeclaration (',' parameters+=ParameterDeclaration)*)? ')' attributes+=Attribute* statement=CompoundStatement
	;

ParameterDeclaration: type=TypeSpecifier declarator=Declarator?;

///////////////////////////////////////////////////////////////////////////////
// Statements
Statement
    :   CompoundStatement
    |   ExpressionStatement
    |   SelectionStatement
    |   IterationStatement
    |   JumpStatement
    |   SpawnStatement
    ;

LabeledStatement
    :   'case' constExpr=ConstantExpression ':' items+=Statement*
    |   {LabeledStatement} 'default' ':' items+=Statement*
    ;

    
CompoundStatement
    :   {CompoundStatement} '{' items+=BlockItem* '}'
    ;

BlockItem
    :   Statement
    |   Declaration
    ;

ExpressionStatement
    :   {ExpressionStatement} expr=AssignmentExpression? ';'
    ;

SelectionStatement
    :   IfStatement
    |   SwitchStatement
    ;
IfStatement
    :   'if' '(' cond=ConditionalExpression ')' thenStmt=Statement (=> 'else' elseStmt=Statement)?
    ;
SwitchStatement
    :   'switch' '(' cond=ConditionalExpression ')' '{' items+=LabeledStatement+ '}'
    ;

IterationStatement
    :   type='while' '(' cond=ConditionalExpression ')' stmt=Statement
    |   type='do' stmt=Statement 'while' '(' cond=ConditionalExpression ')' ';'
    |   type='for' '(' ForCondition ')' stmt=Statement
    ;

fragment ForCondition
	:   (startDecl=Declaration | startExpr=AssignmentExpression? ';') endExpr=ConditionalExpression? ';'  (loopExprs+=AssignmentExpression (',' loopExprs+=AssignmentExpression)*)?
	;

JumpStatement
    :   type='continue' ';'
    |   type='break' ';'
    |   type='return' expr=ConditionalExpression? ';'
    ;

SpawnStatement
    :   'spawn' stmt=Statement
    ;

///////////////////////////////////////////////////////////////////////////////
// Declarations

Declaration:
	(storage+=StorageClassSpecifier | qualifiers+=TypeQualifier | attributes+=Attribute)*
	type=TypeSpecifier (declarators+=InitDeclarator (',' declarators+=InitDeclarator)*)? ';';

Attribute
    :  	DoubleLeftBracket type=ID ('=' params+=ConditionalExpression | '(' params+=ConditionalExpression (',' params+=ConditionalExpression)* ')')? DoubleRightBracket
    ;

TypeSpecifier
	:	ValueTypeSpecifier
	|	VoidTypeSpecifier
	;

ValueTypeSpecifier
	:	PrimitiveTypeSpecifier
	|	CompositeTypeSpecifier
	|	EnumTypeSpecifier
	;

PrimitiveTypeSpecifier
	:	IntegerTypeSpecifier
	|	FloatTypeSpecifier
	|	BoolTypeSpecifier
	;

IntegerTypeSpecifier
	:	signedness=IntegerSignedness (shorthand=IntegerSizeShorthand | '<' size=PrimaryExpression '>')
	|	shorthand=IntegerSizeShorthand
	;

FloatTypeSpecifier
	:	shorthand=FloatSizeShorthand;

BoolTypeSpecifier
	:	{BoolTypeSpecifier} 'bool';

VoidTypeSpecifier
	:	{VoidTypeSpecifier} 'void';

CompositeTypeSpecifier
    :   composeType=StructOrUnion name=ID? '{' (declaration += StructDeclaration)* '}'
    |   composeType=StructOrUnion name=ID
    ;

StructDeclaration
    :   specifier=StructDeclarationSpecifier declarator += Declarator(',' declarator+=Declarator)* ';'
    ;

StructDeclarationSpecifier
    :   type=TypeSpecifier
    |   qualifiers+=TypeQualifier
    ;
	
// TODO add optional size specifier after name? (':' size=IntegerTypeSpecifier)?
EnumTypeSpecifier
    :   'enum' name=ID? '{' enumerators+=EnumMemberDeclaration (',' enumerators+=EnumMemberDeclaration)* ','? '}'
    |   'enum' name=ID
    ;

EnumMemberDeclaration
    :   name=ID
    |   name=ID '=' expression=ConstantExpression
    ;

InitDeclarator:
	declarator=Declarator
	(t_equals='=' initializer=(ExpressionInitializer | ListInitializer))?;

Declarator:
	alias?='&'?
	name=ID
	(LEFT_BR dimensions+=ConstantExpression RIGHT_BR)*
	attributes+=Attribute*;
    
Initializer: ExpressionInitializer | ListInitializer | DesignatedInitializer;

ExpressionInitializer: expr=ConditionalExpression;

ListInitializer: '{' initializers+=Initializer (',' initializers+=Initializer)* ','? '}';

DesignatedInitializer: (designators+=Designator)+ '=' initializer=(ExpressionInitializer | ListInitializer);

Designator: LEFT_BR idx=ConstantExpression RIGHT_BR | '.' prop=ID;

///////////////////////////////////////////////////////////////////////////////
// Expressions

// TODO issue: there is no grammar rule that accepts both a ConditionalExpression and an AssignmentExpression
AssignmentExpression returns Expression // this is right associative
    :   PrefixExpression ({AssignmentExpression.left=current} assignments+=Assignment)*
    ;

// TODO remove this rule completely and instead use right-recursive pattern for AssignmentExpression
Assignment:
	type=('=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '&=' | '^=' | '|=') right=ConditionalExpression
	;

// TODO the then and else branches should allow AssignmentExpression
ConditionalExpression returns Expression
    :   ConcatenationExpression ({ConditionalExpression.cond=current} '?' left=ConditionalExpression ':' right=ConditionalExpression)?
    ;

ConcatenationExpression returns Expression // right associative rule
    :   LogicalOrExpression ({InfixExpression.left=current} op='::' right=ConcatenationExpression)?
    ;
    
LogicalOrExpression returns Expression
    :   LogicalAndExpression ({InfixExpression.left=current} op='||' right=LogicalOrExpression)?
    ;

LogicalAndExpression returns Expression
    :   InclusiveOrExpression ({InfixExpression.left=current} op='&&' right=LogicalAndExpression)?
    ;

InclusiveOrExpression returns Expression
    :   ExclusiveOrExpression ({InfixExpression.left=current} op='|' right=InclusiveOrExpression)?
    ;

ExclusiveOrExpression returns Expression
    :   AndExpression ({InfixExpression.left=current} op='^' right=ExclusiveOrExpression)?
    ;

AndExpression returns Expression
    :   EqualityExpression ({InfixExpression.left=current} op='&' right=AndExpression)?
    ;

EqualityExpression returns Expression
    :   RelationalExpression ({InfixExpression.left=current} op=('=='|'!=') right=EqualityExpression)?
    ;

RelationalExpression returns Expression
    :   ShiftExpression ({InfixExpression.left=current} op=('<'|'>'|'<='|'>=') right=RelationalExpression)?
    ;

ShiftExpression returns Expression
    :   AdditiveExpression ({InfixExpression.left=current} op=('<<'|'>>') right=ShiftExpression)?
    ;

AdditiveExpression returns Expression
    :   MultiplicativeExpression ({InfixExpression.left=current} op=('+'|'-') right=AdditiveExpression)?
    ;

MultiplicativeExpression returns Expression
    :   CastExpression ({InfixExpression.left=current} op=('*' | '/' | '%') right=MultiplicativeExpression)?
    ;

CastExpression
    :   PrefixExpression
    |	'(' type=TypeSpecifier ')' left=CastExpression
    |	'(' signedness=IntegerSignedness ')' left=CastExpression
    ;

PrefixExpression
    :   PostfixExpression
    |   op='++' left=PrefixExpression
    |   op='--' left=PrefixExpression
    |   op=('&' | '*' | '+' | '-' | '~' | '!') left=CastExpression
    |   op='sizeof' '(' (left=PostfixExpression |  type=TypeSpecifier ) ')'
//    |   op='_Alignof' '(' type=TypeSpecifier ')'
    ;

PostfixExpression:
	PrimaryExpression
	(	{FunctionCallExpression.left=current} '(' (arguments+=ConditionalExpression (',' arguments+=ConditionalExpression)*)? ')'
	|	{ArrayAccessExpression.left=current} LEFT_BR index=ConditionalExpression (':' endIndex=ConditionalExpression)? RIGHT_BR
	|	{MemberAccessExpression.left=current} op='.' declarator=[Declarator]
	|	{MemberAccessExpression.left=current} op='->' declarator=[Declarator]
	|	{PostfixExpression.left=current} op='++'
	|	{PostfixExpression.left=current} op='--'
	)*;

PrimaryExpression: EntityReference | Constant | ParenthesisExpression;

ParenthesisExpression: '(' left=ConditionalExpression ')';

EntityReference: target=[NamedEntity];

NamedEntity hidden(): FunctionDefinition | Declarator | BitField;

ConstantExpression returns Expression: ConditionalExpression;
    
///////////////////////////////////////////////////////////////////////////////
// Constants
Constant
	:	IntegerConstant
	|	FloatConstant
	|	CharacterConstant
	|	BoolConstant
	|	StringConstant
	;

IntegerConstant hidden(WS): value=INTEGER;
FloatConstant hidden(WS): value=FLOAT;
CharacterConstant: value=CHARCONST;
BoolConstant: value=BOOLEAN;
StringConstant: literals+=StringLiteral+;
StringLiteral: value=ENCSTRINGCONST | value=STRING ;

// the following 2 rules are needed so that XText does not generate a terminal symbol '[[' and '&&'
// which is always eaten by the Lexer so that a[b[3]] is not recognized
DoubleLeftBracket hidden(WS, ML_COMMENT, SL_COMMENT): LEFT_BR LEFT_BR;
DoubleRightBracket hidden(WS, ML_COMMENT, SL_COMMENT): RIGHT_BR RIGHT_BR;

///////////////////////////////////////////////////////////////////////////////

enum IntegerSignedness : SIGNED='signed' | UNSIGNED='unsigned';

enum IntegerSizeShorthand : INT='int' | CHAR='char' | SHORT='short' |  LONG='long';

enum FloatSizeShorthand : FLOAT='float' | DOUBLE='double';

enum TypeQualifier: CONST='const' | VOLATILE='volatile';

enum StorageClassSpecifier: EXTERN='extern' | STATIC='static' | REGISTER='register';

enum StructOrUnion:   STRUCT='struct'|UNION='union';

terminal LEFT_BR: '[';

terminal RIGHT_BR: ']';

terminal BOOLEAN returns ecore::EBoolean: 'true' | 'false' ;

terminal FLOAT returns ecore::EBigDecimal:  (('0'..'9')+ '.' ('0'..'9')*) (('e' | 'E') ('+' | '-')? ('0'..'9')+)? ('f'|'F'|'l'|'L')?;

terminal INTEGER returns ecore::EBigInteger:  (BINARYINT | HEXADECIMALINT | OCTALINT | DECIMALINT | VLOGINT) ('u'|'U')? (('l'|'L') ('l'|'L')?)?;

terminal fragment BINARYINT:	('0b' | '0B') '0'..'1' (('_')? '0'..'1')*;

terminal fragment OCTALINT:   '0' ('_')? '0'..'7' (('_')? '0'..'7')*;

terminal fragment DECIMALINT:   '0' | '1'..'9' (('_')? '0'..'9')*;

terminal fragment HEXADECIMALINT:   ('0x'|'0X') ('0'..'9'|'a'..'f'|'A'..'F')  (('_')? ('0'..'9'|'a'..'f'|'A'..'F'))*;

terminal fragment VLOGINT: ('0'..'9')+ "'" ('b' ('0'..'1')+ | 'o' ('0'..'7')+ | 'd' ('0'..'9')+ | 'h' ('0'..'9'|'a'..'f'|'A'..'F')+); 

terminal CHARCONST:	('u'|'U'|'L')? "'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'";

@Override 
terminal INT returns ecore::EInt: '~this one has been deactivated';
    
@Override 
terminal ID : '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

// do we need to override the built-in STRING rule?

terminal ENCSTRINGCONST	:	('u8'|'u'|'U'|'L') '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"';
