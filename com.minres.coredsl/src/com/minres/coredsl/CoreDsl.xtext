grammar com.minres.coredsl.CoreDsl with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate coreDsl "http://www.minres.com/coredsl/CoreDsl/2.0"

///////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// Top Level Definitions ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////

DescriptionContent: (imports+=Import)* definitions+=(InstructionSet | CoreDef)+;
Import: 'import' importURI=STRING;

InstructionSet : 'InstructionSet' name=ID ( 'extends' superType=[InstructionSet] )? '{' ISA '}';
CoreDef: 'Core' name=ID ( 'provides' providedInstructionSets+=[InstructionSet] (',' providedInstructionSets+=[InstructionSet])*)? '{' ISA '}';

fragment ISA:
	('architectural_state' '{' (declarations+=DeclarationStatement | assignments+=ExpressionStatement | types+=UserTypeDeclaration)+ '}')? &
	('functions' '{' functions+=FunctionDefinition+ '}')? &
	('instructions' commonInstructionAttributes+=Attribute* '{' instructions+=Instruction+ '}')?;

FunctionDefinition:
    extern?='extern' returnType=TypeSpecifier name=ID '(' (parameters+=ParameterDeclaration (',' parameters+=ParameterDeclaration)*)? ')' ';'
    | returnType=TypeSpecifier name=ID '(' (parameters+=ParameterDeclaration (',' parameters+=ParameterDeclaration)*)? ')' attributes+=Attribute* body=CompoundStatement
    ;

Instruction:
	name=ID attributes+=Attribute* '{' 
		('encoding' ':' encoding=Encoding ';')
		('assembly' ':' assembly=STRING ';')?
		('behavior' ':' behavior=Statement)
	'}';

Encoding: fields+=EncodingField ('::' fields+=EncodingField)*;
EncodingField: BitValue | BitField;
BitValue: value=INTEGER;
BitField: name=ID LEFT_BR startIndex=IntegerConstant ':' endIndex=IntegerConstant RIGHT_BR;

////////////////////////////////////////////////////////////////////////////
//////////////////////////////// Statements ////////////////////////////////
////////////////////////////////////////////////////////////////////////////

Statement:
	EmptyStatement
	| SpawnStatement
	| CompoundStatement
	| ExpressionStatement
	| DeclarationStatement
	| IfStatement
	| SwitchStatement
	| ContinueStatement
	| BreakStatement
	| ReturnStatement
	| LoopStatement;

EmptyStatement: {EmptyStatement} ';';
SpawnStatement: 'spawn' body=Statement;
CompoundStatement: {CompoundStatement} '{' statements+=Statement* '}';
ExpressionStatement: expression=AssignmentExpression ';';
DeclarationStatement: declaration=MultiInitDeclaration ';';

//////////////////////////////// Flow Control ////////////////////////////////

IfStatement:
	'if' '(' condition=Expression ')' thenBody=Statement (=> 'else' elseBody=Statement)?;

SwitchStatement:
	'switch' '(' condition=Expression ')' '{' sections+=SwitchSection* '}';

SwitchSection:
	{CaseSection} 'case' condition=Expression ':' body+=Statement* |
	{DefaultSection} 'default' ':' body+=Statement*;

ContinueStatement: {ContinueStatement} 'continue' ';';
BreakStatement: {BreakStatement} 'break' ';';
ReturnStatement: {ReturnStatement} 'return' value=ConditionalExpression? ';';

//////////////////////////////// Loops ////////////////////////////////

LoopStatement: WhileLoop | ForLoop | DoLoop;

WhileLoop:
	'while' '(' condition=Expression ')' body=Statement;

ForLoop:
	'for' '('
	(startDeclaration=MultiInitDeclaration | startExpression=AssignmentExpression?) ';'
	(condition=Expression?) ';'
	(loopExpressions+=AssignmentExpression (',' loopExpressions+=AssignmentExpression)*)?
	')' body=Statement;

DoLoop:
	'do' body=Statement 'while' '(' condition=Expression ')' ';';

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////// Declarations ////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
	
ParameterDeclaration returns Declaration: Declaration<false, false>;
MultiInitDeclaration returns Declaration: Declaration<true, true>;
MultiDeclaration returns Declaration: Declaration<true, false>;

Declaration<allowMultiple, allowInit>:
	(storage+=StorageClassSpecifier | qualifiers+=TypeQualifier | attributes+=Attribute)*
	type=TypeSpecifier (declarators+=Declarator<allowInit> (<allowMultiple> ',' declarators+=Declarator<allowInit>)*)?;

Declarator<allowInit>:
	alias?='&'?
	name=ID
	(LEFT_BR dimensions+=Expression RIGHT_BR)*
	attributes+=Attribute*
	(<allowInit> t_equals='=' initializer=Initializer)?;

NamedEntity: FunctionDefinition | Declarator<true> | BitField;
    
Initializer: ExpressionInitializer | ListInitializer;
ExpressionInitializer: value=Expression;
ListInitializer: '{' initializers+=Initializer (',' initializers+=Initializer)* ','? '}';

Attribute:
	DoubleLeftBracket type=ID
	('=' parameters+=Expression | '(' parameters+=Expression (',' parameters+=Expression)* ')')?
	DoubleRightBracket;

//////////////////////////////// Type Declarations ////////////////////////////////

UserTypeDeclaration: StructTypeDeclaration | UnionTypeDeclaration | EnumTypeDeclaration;

StructTypeDeclaration: 'struct' name=ID CompositeTypeDeclaration;
UnionTypeDeclaration: 'union' name=ID CompositeTypeDeclaration;
EnumTypeDeclaration: 'enum' name=ID '{' members+=EnumMemberDeclaration (',' members+=EnumMemberDeclaration)* ','? '}';

EnumMemberDeclaration: name=ID ('=' value=Expression)?;

fragment CompositeTypeDeclaration: '{' (members+=MultiDeclaration ';')* '}';

//////////////////////////////// Type Specifiers ////////////////////////////////

TypeSpecifier: VoidTypeSpecifier | PrimitiveTypeSpecifier | UserTypeSpecifier;

PrimitiveTypeSpecifier: IntegerTypeSpecifier | FloatTypeSpecifier | BoolTypeSpecifier;

IntegerTypeSpecifier: shorthand=IntegerSizeShorthand | signedness=IntegerSignedness (shorthand=IntegerSizeShorthand | '<' size=PrimaryExpression '>');
FloatTypeSpecifier: shorthand=FloatSizeShorthand;
BoolTypeSpecifier: {BoolTypeSpecifier} 'bool';
VoidTypeSpecifier: {VoidTypeSpecifier} 'void';

UserTypeSpecifier: StructTypeSpecifier | UnionTypeSpecifier | EnumTypeSpecifier;
	
StructTypeSpecifier: 'struct' target=[StructTypeDeclaration];
UnionTypeSpecifier: 'union' target=[UnionTypeDeclaration];
EnumTypeSpecifier: 'enum' target=[EnumTypeDeclaration];

/////////////////////////////////////////////////////////////////////////////
//////////////////////////////// Expressions ////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

Expression: AssignmentExpression;

AssignmentExpression returns Expression:
	ConditionalExpression
	({AssignmentExpression.target=current}
		operator=('=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '&=' | '^=' | '|=')
		value=AssignmentExpression
	)?;

ConditionalExpression returns Expression:
	ConcatenationExpression
	({ConditionalExpression.condition=current}
		'?' thenExpression=AssignmentExpression
		':' elseExpression=ConditionalExpression
	)?;

ConcatenationExpression returns Expression:
	LogicalOrExpression
	({ConcatenationExpression.parts+=current}
		('::' parts+=LogicalOrExpression)+
	)?;

LogicalOrExpression returns Expression: LogicalAndExpression ({InfixExpression.left=current} operator='||' right=LogicalAndExpression)*;
LogicalAndExpression returns Expression: InclusiveOrExpression ({InfixExpression.left=current} operator='&&' right=InclusiveOrExpression)*;
InclusiveOrExpression returns Expression: ExclusiveOrExpression ({InfixExpression.left=current} operator='|' right=ExclusiveOrExpression)*;
ExclusiveOrExpression returns Expression: AndExpression ({InfixExpression.left=current} operator='^' right=AndExpression)*;
AndExpression returns Expression: EqualityExpression ({InfixExpression.left=current} operator='&' right=EqualityExpression)*;
EqualityExpression returns Expression: RelationalExpression ({InfixExpression.left=current} operator=('=='|'!=') right=RelationalExpression)*;
RelationalExpression returns Expression: ShiftExpression ({InfixExpression.left=current} operator=('<'|'>'|'<='|'>=') right=ShiftExpression)*;
ShiftExpression returns Expression: AdditiveExpression ({InfixExpression.left=current} operator=('<<'|'>>') right=AdditiveExpression)*;
AdditiveExpression returns Expression: MultiplicativeExpression ({InfixExpression.left=current} operator=('+'|'-') right=MultiplicativeExpression)*;
MultiplicativeExpression returns Expression: CastExpression ({InfixExpression.left=current} operator=('*' | '/' | '%') right=CastExpression)*;

CastExpression returns Expression:
	PrefixExpression
	| {CastExpression} '(' targetType=TypeSpecifier ')' operand=CastExpression
	| {CastExpression} '(' signedness=IntegerSignedness ')' operand=CastExpression;

PrefixExpression returns Expression:
	PostfixExpression
	| {PrefixExpression} operator=('++' | '--') operand=PrefixExpression
	| {PrefixExpression} operator=('+' | '-' | '~' | '!') operand=PrefixExpression
    ;

PostfixExpression returns Expression:
	PrimaryExpression
	( {FunctionCallExpression.target=current} '(' (arguments+=Expression (',' arguments+=Expression)*)? ')'
	| {ArrayAccessExpression.target=current} LEFT_BR index=Expression (':' endIndex=Expression)? RIGHT_BR
	| {MemberAccessExpression.target=current} operator='.' declarator=[Declarator]
	| {MemberAccessExpression.target=current} operator='->' declarator=[Declarator]
	| {PostfixExpression.operand=current} operator='++'
	| {PostfixExpression.operand=current} operator='--'
	)*;

PrimaryExpression: ParenthesisExpression | EntityReference | IntrinsicExpression | Constant;

ParenthesisExpression: '(' inner=Expression ')';

EntityReference: target=[NamedEntity];

IntrinsicExpression:
	function=('sizeof' | 'bitsizeof' | 'alignof' | 'offsetof')
	'(' (arguments+=(Expression|TypeSpecifier) (',' arguments+=(Expression|TypeSpecifier))*)? ')';
    
//////////////////////////////// Constants ////////////////////////////////

Constant:
	IntegerConstant
	| FloatConstant
	| CharacterConstant
	| BoolConstant
	| StringConstant;

IntegerConstant hidden(WS): value=INTEGER;
FloatConstant hidden(WS): value=FLOAT;
CharacterConstant: value=CHARCONST;
BoolConstant: value=BOOLEAN;
StringConstant: literals+=StringLiteral+;
StringLiteral: value=ENCSTRINGCONST | value=STRING ;

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////// Enumerations ////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

enum IntegerSignedness : SIGNED='signed' | UNSIGNED='unsigned';
enum IntegerSizeShorthand : INT='int' | CHAR='char' | SHORT='short' |  LONG='long';
enum FloatSizeShorthand : FLOAT='float' | DOUBLE='double';

enum TypeQualifier: CONST='const' | VOLATILE='volatile';
enum StorageClassSpecifier: EXTERN='extern' | STATIC='static' | REGISTER='register';

////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// Terminal Rules ////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// The following 2 rules are needed so that XText does not generate the terminal symbols
// '[[' and ']]', which are always eaten by the lexer so that a[b[3]] is not recognized.
DoubleLeftBracket hidden(WS, ML_COMMENT, SL_COMMENT): LEFT_BR LEFT_BR;
DoubleRightBracket hidden(WS, ML_COMMENT, SL_COMMENT): RIGHT_BR RIGHT_BR;

terminal LEFT_BR: '[';

terminal RIGHT_BR: ']';

terminal BOOLEAN returns ecore::EBoolean: 'true' | 'false' ;

terminal FLOAT returns ecore::EBigDecimal:  (('0'..'9')+ '.' ('0'..'9')*) (('e' | 'E') ('+' | '-')? ('0'..'9')+)? ('f'|'F'|'l'|'L')?;

terminal INTEGER returns ecore::EBigInteger:  (BINARYINT | HEXADECIMALINT | OCTALINT | DECIMALINT | VLOGINT) ('u'|'U')? (('l'|'L') ('l'|'L')?)?;

terminal fragment BINARYINT:	('0b' | '0B') '0'..'1' (('_')? '0'..'1')*;

terminal fragment OCTALINT:   '0' ('_')? '0'..'7' (('_')? '0'..'7')*;

terminal fragment DECIMALINT:   '0' | '1'..'9' (('_')? '0'..'9')*;

terminal fragment HEXADECIMALINT:   ('0x'|'0X') ('0'..'9'|'a'..'f'|'A'..'F')  (('_')? ('0'..'9'|'a'..'f'|'A'..'F'))*;

terminal fragment VLOGINT: ('0'..'9')+ "'" ('b' ('0'..'1')+ | 'o' ('0'..'7')+ | 'd' ('0'..'9')+ | 'h' ('0'..'9'|'a'..'f'|'A'..'F')+); 

terminal CHARCONST:	('u'|'U'|'L')? "'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'";

@Override 
terminal INT returns ecore::EInt: '~this one has been deactivated';
    
@Override 
terminal ID : '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

// do we need to override the built-in STRING rule?

terminal ENCSTRINGCONST	:	('u8'|'u'|'U'|'L') '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"';
