/*
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.scoping

import com.minres.coredsl.coreDsl.BitField
import com.minres.coredsl.coreDsl.CompoundStatement
import com.minres.coredsl.coreDsl.CoreDef
import com.minres.coredsl.coreDsl.CoreDslPackage
import com.minres.coredsl.coreDsl.Declaration
import com.minres.coredsl.coreDsl.Declarator
import com.minres.coredsl.coreDsl.FunctionDefinition
import com.minres.coredsl.coreDsl.ISA
import com.minres.coredsl.coreDsl.Instruction
import com.minres.coredsl.coreDsl.InstructionSet
import com.minres.coredsl.coreDsl.PostfixExpression
import com.minres.coredsl.coreDsl.PrimaryExpression
import java.util.List
import java.util.Set
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes

import static extension com.minres.coredsl.util.ModelUtil.*
import com.minres.coredsl.coreDsl.MemberAccessExpression
import com.minres.coredsl.coreDsl.NamedEntity
import com.minres.coredsl.coreDsl.EntityReference
import com.minres.coredsl.coreDsl.ForLoop
import com.minres.coredsl.coreDsl.Statement
import com.minres.coredsl.coreDsl.DeclarationStatement
import com.minres.coredsl.coreDsl.UserTypeSpecifier
import com.minres.coredsl.coreDsl.EnumTypeSpecifier
import com.minres.coredsl.coreDsl.StructTypeSpecifier
import com.minres.coredsl.coreDsl.UnionTypeSpecifier

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class XtCoreDslScopeProvider extends CoreDslScopeProvider {
	
	int nesting = 0;

	override IScope getScope(EObject context, EReference reference){
		nesting++;
		val res = getScopeInternal(context, reference);
		nesting--;
		//println('''«'  '.repeat(nesting)»«reference.EReferenceType.name» [«context.class.simpleName»]: «res.allElements.map[it.toString].join(', ')»''');
		return res;
	}

    def IScope getScopeInternal(EObject context, EReference reference){
        //println("scopre for "+reference.name+"(class "+reference.EReferenceType.name+") in context "+context.eClass.name)
        if(reference.EReferenceType == CoreDslPackage.Literals.NAMED_ENTITY) {
            switch(context){
                PrimaryExpression:
                    context.containingStatement.scopeForVariable(reference)
                Statement:
                    context.scopeForVariable(reference)
                InstructionSet:
                    Scopes.scopeFor(context.variables, context.superType !== null? context.superType.scopeForVariable(reference) : IScope.NULLSCOPE)
                CoreDef:
                    Scopes.scopeFor(context.variables, context.providedInstructionSets.outerScope)
                default:
                    super.getScope(context, reference)
            }
        } else if(reference.EReferenceType == CoreDslPackage.Literals.DECLARATOR) {
            //val parent = context.eContainer
            // TODO for some reason, parent.Declarator.eContainer is null here
            /*if(parent instanceof PostfixExpression) {
                val type = (parent.Declarator .eContainer.eContainer as Declaration).type
                if( type instanceof CompositeType) {
                    val decls = type.directDeclarations;
                    return Scopes.scopeFor(decls)
                }                
            }
            */
            IScope.NULLSCOPE            
        } else
            super.getScope(context, reference)
    }
    
    def Statement containingStatement(EObject obj){
        if(obj instanceof Statement)
            return obj
        else if(obj.eContainer !== null)
            obj.eContainer.containingStatement
        else 
            null
    }

    def IScope scopeForVariable(InstructionSet isa, EReference reference) {
        Scopes.scopeFor(isa.variables, isa.superType !== null? isa.superType.scopeForVariable(reference) : IScope.NULLSCOPE)
    }

    def IScope scopeForVariable(CoreDef coreDef, EReference reference) {
        Scopes.scopeFor(coreDef.variables, coreDef.providedInstructionSets.outerScope)
    }

    def IScope scopeForVariable(Statement context, EReference reference) {
        val parent = context.eContainer
        val parentScope = switch (parent) {
            CompoundStatement:
                Scopes.scopeFor(parent.variablesDeclaredBefore(context), parent.scopeForVariable(reference))
            Instruction:
                Scopes.scopeFor(EcoreUtil2.getAllContentsOfType(parent, BitField),
                    parent.parentOfType(ISA).getScope(reference))
            FunctionDefinition:
                Scopes.scopeFor(EcoreUtil2.getAllContentsOfType(parent, Declarator),
                    parent.parentOfType(ISA).getScope(reference))
            default:
                parent.getScope(reference)
        }
        if (context instanceof ForLoop)
            if (context.startDeclaration !== null)
                return Scopes.scopeFor(context.startDeclaration.declarators, parentScope)
        return parentScope
    }

    private def IScope outerScope(List<InstructionSet> isas) {
    	val Set<String> seen = newHashSet
        val declsList = isas.map[
        	it.variablesList((seen))
        ].flatten.filter[it.size>0].toList
        declsList.asScopes
    }
		
	def IScope asScopes(Iterable<Iterable<NamedEntity>> list){
		if(list.empty)
			IScope.NULLSCOPE
		else
			Scopes.scopeFor(list.last, list.take(list.size-1).asScopes)
	}
		
    private def Iterable<NamedEntity> variables(ISA isa) {
        isa.stateDeclarators + isa.functions
    }

		
	def List<Iterable<NamedEntity>> variablesList(InstructionSet isa, Set<String> seen){
		seen.add(isa.name)
		if(isa.superType !== null && !seen.contains(isa.superType.name)) {
			val ret = isa.superType.variablesList(seen)
			ret.add(isa.variables)
			return ret
		} else
			newLinkedList(isa.variables)
	}

    /************************************************************************
     * declarationsBefore extension methods begin
     */
    def Iterable<Declaration> declarationsBefore(EObject object, Statement decl){
        switch (object) {
            CompoundStatement:
                object.statements.takeWhile [
                    it !== decl
                ].filter[it instanceof DeclarationStatement].map[(it as DeclarationStatement).declaration]
            InstructionSet:
                object.allDeclarations.takeWhile[it!==decl]
            CoreDef:
                object.allDeclarations.takeWhile[it!==decl]
            default:
                #[]
        }
    }
    /*
     * declarationsBefore extension methods end
     ************************************************************************/

    /************************************************************************
     * directDeclarations extension methods begin
     */
    def Iterable<Declaration> allDeclarations(ISA isa) {
        if(isa instanceof InstructionSet) {
            val declsSuper = isa.superType!==null?isa.superType.allDeclarations:#[]
            declsSuper + isa.declarations.map[it.declaration]
        } else if(isa instanceof CoreDef){
            val declsSuper = isa.providedInstructionSets.map[it.allDeclarations].flatten
            declsSuper + isa.declarations.map[it.declaration]
        }
    }
    /*
     * directDeclarations extension methods end
     ************************************************************************/

    /************************************************************************
     * directDeclarations extension methods begin
     */

    def Iterable<Declarator> variablesDeclaredBefore(EObject stmt, EObject o) {
        if(o instanceof Statement)
            stmt.declarationsBefore(o).flatMap[
                it.declarators
            ]
        else
            #[]
    }
    /*
     * directDeclarations extension methods end
     ************************************************************************/

    /************************************************************************
     * directDeclarations extension methods begin
     */
    def dispatch Iterable<Declarator> directDeclarations(Iterable<Declaration> decls) {
        decls.flatMap[it.declarators]
    }

    def dispatch Iterable<Declarator> directDeclarations(Declaration decl) {
        decl.declarators
    }

    def dispatch Iterable<Declarator> directDeclarations(UserTypeSpecifier spec) {
    	switch(spec) {
    		case StructTypeSpecifier: return (spec as StructTypeSpecifier).target.members.flatMap[it.declarators]
    		case UnionTypeSpecifier: return (spec as UnionTypeSpecifier).target.members.flatMap[it.declarators]
    		case EnumTypeSpecifier: return #[]
    	}
    }
    
    def dispatch Iterable<Declarator> directDeclarations(EObject decl) {
        #[]
    }
    /*
     * directDeclarations extension methods end
     ************************************************************************/

    /************************************************************************
     * type extension methods begin
     */
    def dispatch UserTypeSpecifier findUserType(DeclarationStatement decl, (UserTypeSpecifier)=>boolean predicate){
        val res = decl.eContainer.declarationsBefore(decl)
            .map[it.type]
            .filter[it instanceof UserTypeSpecifier]
            .map[it as UserTypeSpecifier]
            .findFirst(predicate)
        res ?: decl.eContainer.eContainer.findUserType(predicate)
    }
        
    def dispatch UserTypeSpecifier findUserType(ISA isa, (UserTypeSpecifier)=>boolean predicate){
        isa.allDeclarations
            .map[it.type]
            .filter[it instanceof UserTypeSpecifier]
            .map[it as UserTypeSpecifier]
            .findFirst(predicate)
    }

    def dispatch UserTypeSpecifier findUserType(EObject object, (UserTypeSpecifier)=>boolean predicate){
        object.eContainer.findUserType(predicate)
    }
    /*
     * type extension methods end
     ************************************************************************/
    
    /************************************************************************
     * Declarator extension methods begin
     */
    def dispatch Declarator Declarator(EntityReference expression) {
        expression.target instanceof Declarator? expression.target as Declarator : null
    }

    def dispatch Declarator Declarator(MemberAccessExpression expression) {
        expression.declarator
    }

    def dispatch Declarator Declarator(PostfixExpression expression) {
        expression.operand.Declarator
    }

    def dispatch Declarator Declarator(EObject object) {
        // dummy implementation as fall back
        println("No implementation of getDeclaration() for " + object.class)
        null
    }
    /*
     * Declarator extension methods end
     ************************************************************************/
}
